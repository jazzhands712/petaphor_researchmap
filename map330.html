<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Concept Map: Cognitive Frameworks, AI Tools, and LLM Advancements</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Optional updated node content file -->
    <!-- <script src="updated_node_content.js"></script> -->
    <style>
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Charter', serif;
            background-color: #000000; /* Fallback */
            background-image: linear-gradient(to bottom, #0c41b3 0%, #1a1a2e 50%, #0c0c1e 85%, #000000 100%);
            color: #f5f5f5;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        #container { width: 100vw; height: 150vh; position: relative; }
        #concept-map { display: block; width: 100%; height: 100%; }
        #title { position: absolute; top: 20px; left: 0; right: 0; text-align: center; z-index: 10; }
        #title h1 { font-size: 18px; margin: 0; padding: 0; color: #f5f5f5; }
        #title h2 { font-size: 14px; margin: 5px 0 0 0; padding: 0; color: #b87333; }
        #legend { position: absolute; top: 20px; right: 20px; left: auto; background-color: rgba(26, 26, 46, 0.8); border: 2px solid #b87333; border-radius: 10px; padding: 20px; z-index: 10; max-width: 360px; }
        #legend h3 { font-size: 24px; margin: 0 0 10px 0; color: #b87333; }
        .legend-section { margin-bottom: 20px; }
        .legend-section:last-child { margin-bottom: 0; }
        .legend-item { display: flex; align-items: center; margin: 6px 0; }
        .legend-color { width: 30px; height: 30px; margin-right: 16px; border-radius: 50%; }
        .legend-line { width: 40px; height: 4px; margin-right: 16px; }
        .legend-text { font-size: 18px; }
        #reference-link { position: absolute; /* Adjusted in JS */ right: 20px; z-index: 10; font-size: 30px; font-style: italic; }
        #reference-link a { color: #b39ddb; text-decoration: none; }
        #reference-link a:hover { text-decoration: underline; color: #f5f5f5; }
        .node { cursor: pointer; }
        .node-circle { stroke: #f5f5f5; stroke-width: 1.5px; opacity: 0.9; }
        .node-shadow { fill: black; opacity: 0.3; }
        .node text { text-anchor: middle; fill: #f5f5f5; pointer-events: none; }
        .node .icon { font-size: 18px; fill: #f5f5f5; }
        .node .node-name, .node .node-name-line2 { font-weight: bold; font-size: 10px; }
        .node .node-description { font-size: 8px; }
        .link { fill: none; transition: stroke-width 0.2s ease, opacity 0.2s ease; }
        .link-hover-path { fill: none; stroke: transparent; stroke-width: 15px; cursor: pointer; }
        .tooltip-group { pointer-events: none; text-align: center; opacity: 0; visibility: hidden; }
        .tooltip-group.visible { opacity: 1; visibility: visible; transition: opacity 0.1s linear; }
        .tooltip-bg { fill: rgba(26, 26, 46, 0.95); stroke: #b87333; stroke-width: 0.8px; rx: 4px; ry: 4px; opacity: 0.9; }
        .tooltip-text { font-size: 9px; fill: #f5f5f5; text-anchor: middle; font-weight: bold; dominant-baseline: central; }
        .node-details { position: absolute; background-color: rgba(26, 26, 46, 0.95); border: 2px solid; border-radius: 8px; padding: 15px; width: 400px; max-height: 80vh; overflow-y: auto; display: none; z-index: 20; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); }
        .node-details h3 { margin: 0 0 10px 0; color: #f5f5f5; font-size: 14px; font-weight: bold; }
        .node-details .section { margin-bottom: 15px; }
        .node-details .section-title { color: #b87333; font-size: 12px; font-weight: bold; margin-bottom: 5px; }
        .node-details .section-content { color: #f5f5f5; font-size: 10px; line-height: 1.4; }
        .node-details .section-content p { margin: 0 0 8px 0; }
        .node-details .examples { font-style: italic; }
        .node-details .citations { font-size: 9px; opacity: 0.8; }
        .node-details .citations p { margin: 0 0 4px 0; word-break: break-word; }
        .close-button { position: absolute; top: 10px; right: 10px; cursor: pointer; font-size: 16px; color: #f5f5f5; background: rgba(0,0,0,0.3); border-radius: 50%; width: 20px; height: 20px; line-height: 20px; text-align: center; }
        .close-button:hover { background: rgba(255,255,255,0.2); }
        .domain-label { font-size: 14px; font-weight: bold; fill: #b87333; text-anchor: middle; }
        .abstraction-label { font-size: 14px; font-weight: bold; fill: #b87333; text-anchor: end; dominant-baseline: middle; }
        @keyframes pulse { 0% { stroke-opacity: 0.3; stroke-width: 1.5px; } 50% { stroke-opacity: 0.8; stroke-width: 3px; } 100% { stroke-opacity: 0.3; stroke-width: 1.5px; } }
        .agi-pulse { animation: pulse 2s infinite; stroke: #ffd700; fill: none; }
        .grid-line { stroke: white; stroke-opacity: 0.05; stroke-width: 0.5; pointer-events: none; }
        .venn-ellipse { fill: rgba(184, 115, 51, 0.06); stroke: rgba(184, 115, 51, 0.2); stroke-width: 1px; pointer-events: none; }
    </style>
</head>
<body>
    <div id="container">
        <div id="title">
            <h1>Cognitive Frameworks, Applied AI Tools, and LLM Advancements</h1>
            <h2>Relationships and Synergies Driving AGI Approximation</h2>
        </div>

        <div id="legend">
             <h3>Legend</h3>
             <div class="legend-section"> <div class="legend-item"><div class="legend-color" style="background-color: #1a237e;"></div><div class="legend-text">High Abstraction (Theory)</div></div> <div class="legend-item"><div class="legend-color" style="background-color: #4527a0;"></div><div class="legend-text">Mid Abstraction (Frameworks)</div></div> <div class="legend-item"><div class="legend-color" style="background-color: #7b1fa2;"></div><div class="legend-text">Low Abstraction (Applications)</div></div> <div class="legend-item"><div class="legend-color" style="background-color: #c2185b;"></div><div class="legend-text">AGI Outcome</div></div> </div>
             <div class="legend-section"> <div class="legend-item"><div class="legend-line" style="background-color: #ffffff;"></div><div class="legend-text">Direct Dependency</div></div> <div class="legend-item"><div class="legend-line" style="background-color: #b39ddb; border-top: 2px dashed #b39ddb;"></div><div class="legend-text">Interdisciplinary Influence</div></div> <div class="legend-item"><div class="legend-line" style="background-color: #b87333;"></div><div class="legend-text">Synergy</div></div> <div class="legend-item"><div class="legend-line" style="background-color: #ffd700; border-top: 2px dotted #ffd700;"></div><div class="legend-text">AGI Connection</div></div> </div>
        </div>
        <div id="reference-link"> <a href="https://notebooklm.google.com/notebook/1b99d424-5e72-455d-a7fe-668f69fb2b23" target="_blank" rel="noopener noreferrer">references</a> </div>
        <div id="node-details" class="node-details"> <span class="close-button" title="Close">×</span> <h3 id="detail-title"></h3> <div class="section"><div class="section-title">Definition</div><div class="section-content" id="detail-definitions"></div></div> <div class="section"><div class="section-title">Examples</div><div class="section-content examples" id="detail-examples"></div></div> <div class="section"><div class="section-title">Citations</div><div class="section-content citations" id="detail-citations"></div></div> </div>

        <!-- SVG Container -->
        <svg id="concept-map"></svg>
    </div>

    <script>
        // Load data or use fallback
        fetch('concept_map_data.json')
             .then(response => response.ok ? response.json() : Promise.reject('Network response was not ok.'))
             .then(data => { createConceptMap(data); })
             .catch(error => { console.warn('Could not load concept_map_data.json:', error, '- Using embedded data.'); createConceptMap(embeddedData); });

        // --- EMBEDDED DATA --- (Assumed to be complete and correct)
        const embeddedData = {
            "nodes": [ {"id":"cmt","name":"Conceptual Metaphor Theory (CMT)","description":"Understanding abstract concepts via concrete ones.","layer":"High","domain":"Cognitive Science","examples":["TIME IS MONEY","ARGUMENT IS WAR","IDEAS ARE FOOD"],"definitions":["Framework positing that metaphor is not just linguistic but a fundamental cognitive mechanism where one conceptual domain (target) is understood in terms of another (source)."],"citations":["Lakoff, G., & Johnson, M. (1980). Metaphors We Live By.","Kramer, O. (2025). Conceptual Metaphor Theory as a Prompting Paradigm... (Source: Kramer_Conceptual Metaphor Theory.pdf)","Source: The Role of Explicit Metaphorical Modeling... (ACL Rolling Review, 2024 - Based on The Role of Explicit Metaphorical Modeling in Redu.pdf)","Hofstadter, D., & Sander, E. (2013). Surfaces and Essences... (Source: Hofstadter_Surfaces and Essences_p1-31.pdf)","Influences frameworks like Metabridge."],"icon":"≈"}, {"id":"category_theory","name":"Category Theory","description":"Abstract algebra of structures and mappings (functors).","layer":"High","domain":"Formal Math","examples":["Functors preserving structure","Natural transformations","Adjunctions","Yoneda Lemma","Sheaves/Copresheaves"],"definitions":["A branch of mathematics dealing with abstract structures and relationships between them, formalized as categories (objects and morphisms) and functors (mappings between categories). Provides foundation for Petaphor's structural mapping."],"citations":["Bradley, T.-D., Terilla, J., & Vlassopoulos, Y. (2022). AN ENRICHED CATEGORY THEORY OF LANGUAGE... (Source: Bradley_Enriched CT.pdf)","Bradley, T.-D., & Vigneaux, J. P. (2025). THE MAGNITUDE OF CATEGORIES OF TEXTS... (Source: Bradley_Magnitude.pdf)","Bradley, T.-D., Gastaldi, J. L., & Terilla, J. (2024). The Structure of Meaning in Language... (Source: structure of meaning.pdf)","Chimes, M., et al. (2025). Category theory. (Source: Chimes_Category Theory Overview.pdf)","Yuan, Y. (2023). A Categorical Framework of General Intelligence. (Source: Category_AGI.pdf)","Mac Lane, S. (1971/1998). Categories for the Working Mathematician."],"icon":"∀"}, {"id":"metaphor_analogy","name":"Metaphor/Analogy","description":"Cognitive mapping between domains.","layer":"High","domain":"Cognitive Science","examples":["Structure-mapping (SME)","Analogical reasoning tasks","Metaphor identification (MIPVU)","MUNCH/ANALOGICAL datasets"],"definitions":["Cognitive processes involving identifying relational similarities and transferring knowledge or structure from a familiar domain (source/base) to a less familiar one (target). Core to human cognition and central inspiration for frameworks like Petaphor/Metabridge."],"citations":["Hofstadter, D., & Sander, E. (2013). Surfaces and Essences... (Source: Hofstadter_Surfaces and Essences_p1-31.pdf)","Gentner, D. (1983). Structure-mapping: A theoretical framework for analogy.","Tong, X., et al. (2024). MUNCH: Evaluating Metaphor Understanding... (Source: 2024.acl-long.193.pdf)","Boisson, J., et al. (2024). Automatic Extraction of Metaphoric Analogies... (Source: Cardiff_Extraction.pdf)","Wijesiriwardene, T., et al. (2024). ANALOGICAL - A Novel Benchmark... (Source: thilini_analogy.pdf)","Michelli, G., Tong, X., & Shutova, E. (2024). A framework for annotating... intentions behind metaphor use. (Source: intentions behind metaphors.pdf)","Webb, T. J., Holyoak, K. J., & Lu, H. (2023). Emergent analogical reasoning... (Cited in MUNCH paper)"],"icon":"↭"}, {"id":"metabridge","name":"Metabridge","description":"CMT-guided LLM prompting framework.","layer":"Mid","domain":"Cognitive Science","examples":["Prompting: 'Explain market competition using an ecosystem metaphor.'","Evaluating LLM's metaphorical reasoning consistency."],"definitions":["A Cognitive-Computational Approach using insights from Conceptual Metaphor Theory to structure prompts for Large Language Models, aiming to improve cross-domain reasoning, explanation, or creativity."],"citations":["Source: METABRIDGE 0.1 Enhanced Metaphorical Reasoning Framework... ([n.d.] - Source: METABRIDGE Summary_rough.pdf)","Related: Kramer, O. (2025). Conceptual Metaphor Theory as a Prompting Paradigm... (Source: Kramer_Conceptual Metaphor Theory.pdf)"],"icon":"⟷"}, {"id":"petaphor","name":"Petaphor","description":"Formal functorial domain mapping via CT.","layer":"Mid","domain":"Formal Math","examples":["Mapping domains based on structural similarity (Correspondence)","Generating derived hypotheses","Requires Domain Induction","Uses CT Principles (Functors, Transformations)"],"definitions":["A framework using Category Theory (specifically principles like correspondence via functors, transformation, fractal depth) to create explicit, structurally-preserved conceptual mappings between domains, aiming to generate novel hypotheses and insights."],"citations":["Primary Source: Petaphor Greypaper v1.8 ([n.d.] - Source: petaphor_greypaper_1.8 .pdf)","Relies heavily on: Bradley, T.-D., et al. (2022). AN ENRICHED CATEGORY THEORY OF LANGUAGE... (Source: Bradley_Enriched CT.pdf)","Context: Gemini_Petaphor Research Summary Podcast.mp3 (Internal context)"],"icon":"⊕"}, {"id":"cross_domain_mapping","name":"Robust Formal Cross-Domain Mapping","description":"Formalizing analogy & metaphor.","layer":"Mid","domain":"Formal Math","examples":["Category Theoretic models (Functors)","Structure-Mapping Engine (SME)","Petaphor's methodology","Metabridge's guided prompting"],"definitions":["The use of formal methods (like Category Theory, logic, graph theory) or structured cognitive approaches (like CMT) to precisely define, compute, or guide the mapping of structures, concepts, and relationships between different domains."],"citations":["Implemented in: Petaphor Greypaper v1.8 ([n.d.] - Source: petaphor_greypaper_1.8 .pdf)","Formalism via: Bradley, T.-D., et al. (2022). AN ENRICHED CATEGORY THEORY OF LANGUAGE... (Source: Bradley_Enriched CT.pdf)","Formalism via: Bradley, T.-D., et al. (2024). The Structure of Meaning in Language... (Source: structure of meaning.pdf)","Cognitive Basis: Gentner, D. (1983). Structure-mapping...","Cognitive Guidance: METABRIDGE 0.1... ([n.d.] - Source: METABRIDGE Summary_rough.pdf)"],"icon":"↦"}, {"id":"llm_applications","name":"LLMs/Machine Learning","description":"Applying frameworks in AI systems.","layer":"Low","domain":"Applied AI","examples":["Metaphor/Analogy detection & evaluation (MUNCH, ANALOGICAL)","Metaphor-guided prompting (Metabridge, Kramer)","Transfer Learning","Hypothesis generation (Petaphor goal)"],"definitions":["Practical implementations and uses of Large Language Models and other ML techniques to perform tasks related to or enhanced by cognitive/formal frameworks like metaphor, analogy, CT, Petaphor, and Metabridge."],"citations":["Evaluation: Tong, X., et al. (2024). MUNCH... (Source: 2024.acl-long.193.pdf)","Evaluation: Wijesiriwardene, T., et al. (2024). ANALOGICAL... (Source: thilini_analogy.pdf)","Prompting: Kramer, O. (2025). Conceptual Metaphor Theory as a Prompting Paradigm... (Source: Kramer_Conceptual Metaphor Theory.pdf)","Prompting Context: o.k. First Metaphorical Prompts (Deepseek, 1/30/25) (Internal context)","Capabilities/Limitations: Alkhamissi, B., & ElNokrashy, M. (2023). Shadow-Cave Models... (Source: PlatosCave.pdf)","Capabilities: Webb, T. J., et al. (2023). Emergent analogical reasoning...","Related Task: Chronopoulou, A., et al. (2020). An Embarrassingly Simple Approach for Transfer Learning... (Source: embarrassinglysimple_allgreektome.pdf)","LLM Context: DEEPSEEK analysis current research.txt (Internal context)"],"icon":"λ"}, {"id":"case_studies","name":"Case Studies","description":"Specific framework applications.","layer":"Low","domain":"Applied AI","examples":["'Economic Mycorrhizae'","'Symbiotic conflict resolution'","Mappings explored in Petaphor (Propaganda/Physics)","Prompts tested (Deepseek, GPT o1)"],"definitions":["Concrete examples or detailed analyses demonstrating the application and potential output of frameworks like Petaphor (e.g., generating hypotheses from mappings) or Metabridge (e.g., testing specific metaphorical prompts)."],"citations":["Likely derived from/tested in: Petaphor Greypaper v1.8 ([n.d.] - Source: petaphor_greypaper_1.8 .pdf)","Prompting examples context: GPT o1 - Metaphor applied to Alignment Algorithm Ideation (2025) (Internal context)","Prompting examples context: o.k. First Metaphorical Prompts (Deepseek, 1/30/25) (Internal context)"],"icon":"⚙"}, {"id":"alignment_risk","name":"Potential Alignment Risk Mitigation","description":"Using CT/formal methods for AI safety.","layer":"Low","domain":"Applied AI","examples":["Formalizing objectives using CT","Invariant properties as safety constraints","Metaphor applied to Alignment Algorithm Ideation"],"definitions":["Applying Category Theory and other formal or structured cognitive approaches (like metaphor) to address the AI alignment problem: ensuring advanced AI systems behave consistently with human values and intentions."],"citations":["Yuan, Y. (2023). A Categorical Framework of General Intelligence. (Addresses Alignment via CT - Source: Category_AGI.pdf)","Application Idea: GPT o1 - Metaphor applied to Alignment Algorithm Ideation (2025) (Internal context)"],"icon":"⚠"}, {"id":"novel_concept","name":"Novel Concept Synthesis / Hypothesis Generation","description":"Generating new ideas via structured mapping.","layer":"Low","domain":"Applied AI","examples":["Generating scientific hypotheses (Petaphor goal)","Creative metaphorical connections","Blending concepts from disparate domains"],"definitions":["The process, guided by frameworks like Petaphor (formal) or Metabridge (cognitive), of generating new concepts, testable hypotheses, or creative solutions by systematically combining or mapping elements from existing, potentially unrelated, conceptual domains."],"citations":["Primary Goal of: Petaphor Greypaper v1.8 ([n.d.] - Source: petaphor_greypaper_1.8 .pdf)","Cognitive Basis: Fauconnier, G., & Turner, M. (2002). The Way We Think: Conceptual Blending...","Cognitive Basis: Hofstadter, D., & Sander, E. (2013). Surfaces and Essences..."],"icon":"✧"}, {"id":"agi","name":"Emergent Human-Like Cognition","description":"Approximation via integrated frameworks.","layer":"AGI","domain":"All","examples":["Flexible cross-domain reasoning","Creative problem solving","Abstract thinking","Potential for alignment"],"definitions":["The potential future outcome where Artificial General Intelligence, exhibiting human-like flexibility, creativity, abstraction, and alignment, emerges from the successful integration and scaling of cognitive (analogy, metaphor) and formal (Category Theory, structured mapping) approaches."],"citations":["Formal Framework Perspective: Yuan, Y. (2023). A Categorical Framework of General Intelligence. (Source: Category_AGI.pdf)","Emergent Capabilities: Webb, T. J., et al. (2023). Emergent analogical reasoning...","Cognitive Science Perspective: Lake, B. M., et al. (2017). Building machines that learn and think like people.","Underlying Ability: Hofstadter, D., & Sander, E. (2013). Surfaces and Essences..."],"icon":"Ω"}
            ],
            "connections": [ {"source":"cmt","target":"metabridge","type":"direct","description":"CMT provides cognitive foundation"},{"source":"cmt","target":"metaphor_analogy","type":"direct","description":"CMT explains metaphor's cognitive role"},{"source":"cmt","target":"cross_domain_mapping","type":"direct","description":"CMT describes the mappings"},{"source":"cmt","target":"petaphor","type":"interdisciplinary","description":"CMT informs metaphorical spaces"},{"source":"category_theory","target":"petaphor","type":"direct","description":"CT formalizes Petaphor mappings"},{"source":"category_theory","target":"cross_domain_mapping","type":"direct","description":"CT provides formal tools (functors)"},{"source":"category_theory","target":"alignment_risk","type":"direct","description":"CT potentially aids formal alignment"},{"source":"category_theory","target":"llm_applications","type":"interdisciplinary","description":"CT offers abstract view of structures"},{"source":"metaphor_analogy","target":"cross_domain_mapping","type":"direct","description":"Analogy research informs mapping"},{"source":"metaphor_analogy","target":"llm_applications","type":"direct","description":"LLMs used for analogy/metaphor tasks"},{"source":"metaphor_analogy","target":"agi","type":"agi_connection","description":"Analogy is core to human cognition"},{"source":"metabridge","target":"llm_applications","type":"direct","description":"Metabridge is applied via LLMs"},{"source":"petaphor","target":"cross_domain_mapping","type":"direct","description":"Petaphor implements formal mapping"},{"source":"petaphor","target":"novel_concept","type":"direct","description":"Petaphor aims to generate novelty"},{"source":"cross_domain_mapping","target":"llm_applications","type":"direct","description":"Formal mapping enhances LLMs"},{"source":"cross_domain_mapping","target":"novel_concept","type":"direct","description":"Formal mapping enables synthesis"},{"source":"llm_applications","target":"case_studies","type":"direct","description":"LLMs used in case studies"},{"source":"llm_applications","target":"agi","type":"agi_connection","description":"LLMs are building blocks"},{"source":"alignment_risk","target":"llm_applications","type":"direct","description":"Alignment methods applied to LLMs"},{"source":"alignment_risk","target":"agi","type":"agi_connection","description":"Alignment is crucial for safe AGI"},{"source":"novel_concept","target":"agi","type":"agi_connection","description":"Synthesis contributes to creativity"},{"source":"case_studies","target":"agi","type":"agi_connection","description":"Case studies demonstrate progress"},{"source":"cmt","target":"llm_applications","type":"interdisciplinary","description":"CMT informs LLM metaphor tasks"},{"source":"category_theory","target":"metabridge","type":"interdisciplinary","description":"CT could formalize Metabridge"},{"source":"metabridge","target":"case_studies","type":"interdisciplinary","description":"Metabridge applied in studies"},{"source":"petaphor","target":"case_studies","type":"interdisciplinary","description":"Petaphor applied in studies"},{"source":"cross_domain_mapping","target":"case_studies","type":"interdisciplinary","description":"Mapping methods used in studies"},{"source":"metaphor_analogy","target":"metabridge","type":"interdisciplinary","description":"Analogy informs Metabridge design"},{"source":"metaphor_analogy","target":"petaphor","type":"interdisciplinary","description":"Analogy informs Petaphor structure"},{"source":"cmt","target":"category_theory","type":"synergy","description":"CMT + CT → Formal Metaphor"},{"source":"metabridge","target":"petaphor","type":"synergy","description":"Cognitive + Formal Mapping"},{"source":"cross_domain_mapping","target":"metaphor_analogy","type":"synergy","description":"Formal + Cognitive Models"},{"source":"llm_applications","target":"novel_concept","type":"synergy","description":"LLMs + Synthesis → Creative AI"},{"source":"cmt","target":"agi","type":"agi_connection","description":"Human-like abstraction"},{"source":"category_theory","target":"agi","type":"agi_connection","description":"Structured reasoning foundation"},{"source":"metabridge","target":"agi","type":"agi_connection","description":"Enhanced reasoning"},{"source":"petaphor","target":"agi","type":"agi_connection","description":"Formal creativity"},{"source":"cross_domain_mapping","target":"agi","type":"agi_connection","description":"Flexible thinking"}
            ],
            "colors": { "background": "#1a1a2e", "high_abstraction": { "primary": "#1a237e" }, "mid_abstraction": { "primary": "#4527a0" }, "low_abstraction": { "primary": "#7b1fa2" }, "agi": { "primary": "#c2185b" }, "gold": "#ffd700", "copper": "#b87333", "highlight": "#f5f5f5", "direct": "#ffffff", "interdisciplinary": "#b39ddb", "synergy": "#b87333", "agi_connection": "#ffd700" }
        };


        function createConceptMap(data) {
            const svg = d3.select("#concept-map");
            const container = document.getElementById("container");
            const view_width = container.clientWidth;
            const height = container.clientHeight; // Use container height (150vh)

            // Ensure SVG size is set (redundant if CSS is correct, but safe)
            svg.attr("width", view_width).attr("height", height);

            const defs = svg.append("defs");
            // Optional filter definitions...

            // --- Layout Configuration ---
            const nodeRadius = 84.375; // Increased by factor of 1.25 (from 67.5)
            const horizontalPadding = view_width * 0.12;
            const titleHeightOffset = 140;
            const bottomPaddingOffset = 80;
            const topEffectivePadding = titleHeightOffset;
            const bottomEffectivePadding = height - bottomPaddingOffset;

            const xScale = d3.scaleLinear().domain([0, 1]).range([horizontalPadding, view_width - horizontalPadding]);
            const yScale = d3.scaleLinear().domain([0, 1]).range([bottomEffectivePadding, topEffectivePadding]);

            const initialNodePositions = {
                "cmt": { x: 0.2, y: 0.9 }, "category_theory": { x: 0.8, y: 0.9 },
                "metaphor_analogy": { x: 0.5, y: 0.9 }, "metabridge": { x: 0.2, y: 0.65 },
                "petaphor": { x: 0.8, y: 0.65 }, "cross_domain_mapping": { x: 0.5, y: 0.65 },
                "llm_applications": { x: 0.4, y: 0.35 }, "case_studies": { x: 0.5, y: 0.35 },
                "alignment_risk": { x: 0.6, y: 0.35 }, "novel_concept": { x: 0.5, y: 0.35 },
                "agi": { x: 0.5, y: 0.1 }
            };

            // Set initial positions and fix AGI node
            data.nodes.forEach(node => {
                const position = initialNodePositions[node.id];
                node.x = position ? xScale(position.x) : view_width / 2;
                node.y = position ? yScale(position.y) : height / 2;
                if (node.id === "agi") {
                    node.fx = node.x; node.fy = node.y;
                } else {
                    node.fx = null; node.fy = null;
                }
            });

            // --- Create SVG Groups ---
            const backgroundGroup = svg.append("g").attr("id", "background-elements");
            const linkGroupContainer = svg.append("g").attr("class", "links-container");
            const nodeGroupContainer = svg.append("g").attr("class", "nodes-container");
            const labelGroup = svg.append("g").attr("id", "label-elements");
            const tooltipLayer = svg.append("g").attr("id", "tooltip-layer").attr("pointer-events", "none");

            // --- Draw Venn Ellipses ---
            const effectiveHeight = bottomEffectivePadding - topEffectivePadding;
            const ellipseData = [
                { id: "cogsci", cx: xScale(0.30), cy: yScale(0.75), rx: view_width * 0.28, ry: effectiveHeight * 0.35 },
                { id: "formal", cx: xScale(0.70), cy: yScale(0.75), rx: view_width * 0.28, ry: effectiveHeight * 0.35 },
                { id: "applied", cx: xScale(0.5), cy: yScale(0.30), rx: view_width * 0.30, ry: effectiveHeight * 0.25 }
            ];
            backgroundGroup.selectAll(".venn-ellipse").data(ellipseData).enter().append("ellipse")
                .attr("class", "venn-ellipse").attr("cx", d => d.cx).attr("cy", d => d.cy)
                .attr("rx", d => d.rx).attr("ry", d => d.ry);

            // --- Draw Axis Labels and Grid ---
            const domainLabels = ["Cognitive Science", "Formal Math", "Applied AI"];
            const domainLabelX = [0.3, 0.75, 0.5];
            labelGroup.selectAll(".domain-label").data(domainLabels).enter().append("text")
                .attr("class", "domain-label").attr("x", (d, i) => xScale(domainLabelX[i]))
                .attr("y", topEffectivePadding - 30).text(d => d);

            const abstractionLabels = ["High Abstraction", "Mid Abstraction", "Low Abstraction", "AGI Outcome"];
            const abstractionYPositions = [0.9, 0.65, 0.35, 0.1];
            labelGroup.selectAll(".abstraction-label").data(abstractionLabels).enter().append("text")
                .attr("class", "abstraction-label").attr("x", horizontalPadding - 20)
                .attr("y", (d, i) => yScale(abstractionYPositions[i])).text(d => d);

            backgroundGroup.selectAll(".horizontal-grid").data(abstractionYPositions).enter().append("line").attr("class", "grid-line").attr("x1", horizontalPadding).attr("y1", d => yScale(d)).attr("x2", view_width - horizontalPadding).attr("y2", d => yScale(d));
            backgroundGroup.selectAll(".vertical-grid").data(domainLabelX).enter().append("line").attr("class", "grid-line").attr("x1", d => xScale(d)).attr("y1", topEffectivePadding).attr("x2", d => xScale(d)).attr("y2", bottomEffectivePadding);

            // --- Arrow Markers ---
            const markerRefX = nodeRadius / 9;
             defs.selectAll("marker").data(["direct", "interdisciplinary", "synergy", "agi_connection"]).enter().append("marker")
                 .attr("id", d => `arrow-${d}`).attr("viewBox", "0 -5 10 10").attr("refX", markerRefX)
                 .attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto-start-reverse")
                 .append("path").attr("d", "M10,-5L0,0L10,5").attr("fill", d => data.colors[d] || embeddedData.colors[d] || "#ffffff");

            // --- Draw Connections ---
            // Use data.connections which are now enriched with source/target objects by the simulation
            const linkGroups = linkGroupContainer.selectAll(".link-group")
                .data(data.connections, d => `${d.source.id}-${d.target.id}`) // Key function using node IDs
                .join("g").attr("class", "link-group").attr("id", (d, i) => `link-group-${i}`);

            function calculatePath(d) {
                // Check if source/target and their coords are defined
                if (!d.source || !d.target || typeof d.source.x !== 'number' || typeof d.source.y !== 'number' || typeof d.target.x !== 'number' || typeof d.target.y !== 'number') {
                     // console.warn("Skipping path for link with missing data:", d);
                    return "M0,0 L0,0"; // Return a minimal valid path
                }
                const sourceX = d.source.x, sourceY = d.source.y; const targetX = d.target.x, targetY = d.target.y;
                const dx = targetX - sourceX, dy = targetY - sourceY; const dist = Math.sqrt(dx * dx + dy * dy); if (dist < 1) return `M${sourceX},${sourceY}`; // Avoid division by zero or tiny distances
                const offsetX = (dx * nodeRadius) / dist, offsetY = (dy * nodeRadius) / dist;
                const startX = sourceX + offsetX, startY = sourceY + offsetY; const endX = targetX - offsetX, endY = targetY - offsetY;
                const midX = (startX + endX) / 2, midY = (startY + endY) / 2; const curveFactor = 0.15; const controlX = midX + curveFactor * (startY - endY); const controlY = midY + curveFactor * (endX - startX);
                if (Math.abs(controlX - midX) < 1e-6 && Math.abs(controlY - midY) < 1e-6) return `M${startX},${startY}L${endX},${endY}`;
                return `M${startX},${startY} Q${controlX},${controlY} ${endX},${endY}`;
            }

            // Append paths only once using join's enter selection
            const links = linkGroups.append("path").attr("class", d => `link ${d.type}`)
                 .attr("stroke", d => data.colors[d.type] || embeddedData.colors[d.type] || "#ffffff")
                 .attr("stroke-width", d => (d.type === "synergy" ? 2.5 : (d.type === "direct" ? 2 : 1.5)))
                 .attr("stroke-dasharray", d => (d.type === "interdisciplinary" ? "5,3" : (d.type === "agi_connection" ? "2,2" : null)))
                 .attr("marker-end", d => `url(#arrow-${d.type})`)
                 .attr("opacity", d => (d.type === "interdisciplinary" ? 0.7 : 0.9));
                 // 'd' attribute will be set in ticked function

            const linkHoverPaths = linkGroups.append("path").attr("class", "link-hover-path")
                 // 'd' attribute will be set in ticked function
                 .on("mouseover", function(event, d) {
                    const linkGroupElement = d3.select(this.parentNode);
                    linkGroupElement.select(".link").attr("opacity", 1).attr("stroke-width", sd => (sd.type === "synergy" ? 3.5 : (sd.type === "direct" ? 3 : 2.5)));
                    const tooltip = tooltipLayer.append("g").attr("class", "tooltip-group");
                    const [initX, initY] = d3.pointer(event, svg.node());
                    tooltip.attr("transform", `translate(${initX + 15}, ${initY - 15})`);
                    const tooltipText = tooltip.append("text").attr("class", "tooltip-text").attr("dy", "0em").text(d.description);
                    const bbox = tooltipText.node().getBBox();
                    tooltip.insert("rect", "text").attr("class", "tooltip-bg").attr("x", bbox.x - 5).attr("y", bbox.y - 3).attr("width", bbox.width + 10).attr("height", bbox.height + 6);
                    tooltip.classed("visible", true);
                    d3.select(this).on("mousemove.tooltip", function(moveEvent) { const [mouseX, mouseY] = d3.pointer(moveEvent, svg.node()); tooltip.attr("transform", `translate(${mouseX + 15}, ${mouseY - 15})`); });
                 })
                .on("mouseout", function(event, d) {
                    const linkGroupElement = d3.select(this.parentNode);
                    linkGroupElement.select(".link").attr("opacity", sd => (sd.type === "interdisciplinary" ? 0.7 : 0.9)).attr("stroke-width", sd => (sd.type === "synergy" ? 2.5 : (sd.type === "direct" ? 2 : 1.5)));
                    tooltipLayer.selectAll("*").remove();
                    d3.select(this).on("mousemove.tooltip", null);
                 });

            // --- Draw Nodes ---
            const nodeGroups = nodeGroupContainer.selectAll(".node")
                .data(data.nodes, d => d.id) // Use key function
                .join( // Use .join() for enter/update/exit logic
                    enter => { // Define how new nodes are added
                        const g = enter.append("g").attr("class", "node")
                            .attr("transform", d => `translate(${d.x || 0}, ${d.y || 0})`) // Set initial position
                            .call(d3.drag().on("start", dragStarted).on("drag", dragged).on("end", dragEnded)); // Apply drag

                        g.append("circle").attr("class", "node-shadow").attr("r", nodeRadius + 1).attr("cx", 1).attr("cy", 1);
                        g.append("circle").attr("class", "node-circle").attr("r", nodeRadius).attr("fill", d => getNodeColor(d.layer)); // Set fill on enter
                        g.filter(d => d.id === "agi").append("circle").attr("class", "agi-pulse").attr("r", nodeRadius + 4).attr("cx", 0).attr("cy", 0);
                        g.append("text").attr("class", "icon").attr("y", -nodeRadius * 0.45).text(d => d.icon);
                        g.each(function(d) { // Add name lines
                            const group = d3.select(this);
                            const nameParts = d.name.split(/\s*\(/);
                            const nameFontSize = 10; const lineSpacing = nameFontSize * 1.2;
                            group.append("text").attr("class", "node-name").attr("y", nameParts.length > 1 ? -lineSpacing / 2 : 0).text(nameParts[0].trim());
                            if (nameParts.length > 1) { group.append("text").attr("class", "node-name-line2").attr("y", lineSpacing / 2).text("(" + nameParts[1].trim()); }
                        });
                        g.append("text").attr("class", "node-description").attr("y", nodeRadius * 0.5).text(d => { const maxLen = 45; return d.description.length > maxLen ? d.description.substring(0, maxLen - 3) + "..." : d.description; });

                        // Add click listener to the group on enter
                         g.on("click", function(event, d) {
                             // console.log("Node clicked (handler on g):", d.id); // Debug log
                             showNodeDetails(d, event, embeddedData);
                         });
                         g.on("mouseover", function(event, d) { /* ... hover logic ... */ });
                         g.on("mouseout", function(event, d) { /* ... hover logic ... */ });

                        return g;
                    },
                    update => update, // No specific update actions needed here as position is handled by tick
                    exit => exit.remove() // Remove nodes that are no longer in data
                );

            // --- Force Simulation Setup ---
            const centerY = (topEffectivePadding + bottomEffectivePadding) / 2;
            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.connections).id(d => d.id).distance(562.5).strength(0.5)) // Increased distance by factor of 1.25 (from 450)
                .force("charge", d3.forceManyBody().strength(-550)) // Stronger repulsion
                .force("collide", d3.forceCollide(nodeRadius + 20)) // Increased collision buffer
                .force("center", d3.forceCenter(view_width / 2, centerY))
                .force("x", d3.forceX().x(d => initialNodePositions[d.id] ? xScale(initialNodePositions[d.id].x) : view_width / 2).strength(0.05))
                .force("y", d3.forceY().y(d => initialNodePositions[d.id] ? yScale(initialNodePositions[d.id].y) : height / 2).strength(0.05))
                .on("tick", ticked);

            // --- Tick Function ---
            function ticked() {
                // Bound nodes within the EFFECTIVE drawing area
                const buffer = nodeRadius * 0.5;
                nodeGroups.attr("transform", d => {
                    // Check if coordinates are numbers before clamping
                    const currentX = (typeof d.x === 'number' && !isNaN(d.x)) ? d.x : view_width / 2;
                    const currentY = (typeof d.y === 'number' && !isNaN(d.y)) ? d.y : centerY;

                    d.x = Math.max(horizontalPadding - buffer, Math.min(view_width - horizontalPadding + buffer, currentX));
                    d.y = Math.max(topEffectivePadding - buffer, Math.min(bottomEffectivePadding + buffer, currentY));

                    if(d.fx != null) d.x = d.fx;
                    if(d.fy != null) d.y = d.fy;
                    return `translate(${d.x}, ${d.y})`;
                });

                // Update link paths only if source and target have valid coordinates
                links.attr("d", calculatePath);
                linkHoverPaths.attr("d", calculatePath);
            }

             // --- Drag Functions ---
             function dragStarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
             function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
             function dragEnded(event, d) { if (!event.active) simulation.alphaTarget(0); if (d.id !== "agi") { d.fx = null; d.fy = null; } }

            // --- Node Interactivity (Listeners now attached during .join() enter selection) ---
            // nodeGroups.on("click", ...) // Moved to .join() enter
            // nodeGroups.on("mouseover", ...) // Can keep these here or move to .join() enter
            // nodeGroups.on("mouseout", ...)

            // --- Node Details Panel ---
             const detailsPanel = d3.select("#node-details");
             const closeButton = detailsPanel.select(".close-button");
             closeButton.on("click", () => detailsPanel.style("display", "none"));
             d3.select('body').on('click', function(event) { const targetElement = event.target; if (!detailsPanel.node().contains(targetElement) && !d3.select(targetElement.closest('.node')).size() && detailsPanel.style('display') === 'block') { detailsPanel.style('display', 'none'); } });

             // Adjust reference link position
             const legendElement = document.getElementById('legend');
             if (legendElement) { const legendRect = legendElement.getBoundingClientRect(); d3.select('#reference-link').style('top', `${legendRect.bottom + 10 + window.scrollY}px`); } // Add scrollY for absolute positioning

        } // End createConceptMap

        // --- Helper Functions ---
         function showNodeDetails(node, event, data) {
             event.stopPropagation(); // Prevent body click closing immediately
            // console.log("Showing details for:", node.id); // Debug log
            const detailsPanel = d3.select("#node-details");
            let nodeContent = { ...node };
            if (window.updatedNodeContent && window.updatedNodeContent[node.id]) { nodeContent = { ...node, ...window.updatedNodeContent[node.id] }; }
            detailsPanel.select("#detail-title").text(nodeContent.name);
            detailsPanel.select("#detail-definitions").html("").selectAll("p").data(nodeContent.definitions || ["N/A"]).join("p").html(d => d); // Use join
            detailsPanel.select("#detail-examples").html("").selectAll("p").data(nodeContent.examples || ["N/A"]).join("p").html(d => d); // Use join
            detailsPanel.select("#detail-citations").html("").selectAll("p").data(nodeContent.citations || ["No citations provided."]).join("p").html(d => d); // Use join
            detailsPanel.style("border-color", getNodeColor(nodeContent.layer));

             // Position panel relative to viewport, not page scroll
            const panelWidth = 400, panelHeightEstimate = 300, margin = 20;
            let panelX = event.clientX + margin; // Use clientX for viewport coord
            let panelY = event.clientY - panelHeightEstimate / 2; // Use clientY for viewport coord

            // Ensure panel stays within *viewport*
            if (panelX + panelWidth > window.innerWidth - margin) panelX = event.clientX - panelWidth - margin;
            if (panelX < margin) panelX = margin;
            if (panelY < margin) panelY = margin;

             // Make panel fixed position and display
             detailsPanel.style("position", "fixed") // Use fixed to ignore scroll
                        .style("left", `${panelX}px`).style("top", `${panelY}px`)
                        .style("display", "block");

             // Check bottom boundary based on viewport height AFTER display
             const actualHeight = detailsPanel.node().offsetHeight;
             if (panelY + actualHeight > window.innerHeight - margin) {
                 panelY = window.innerHeight - actualHeight - margin;
                 if (panelY < margin) panelY = margin;
                 detailsPanel.style("top", `${panelY}px`);
             }
         }

         function getNodeColor(layer) {
             if (typeof embeddedData === 'undefined' || !embeddedData.colors) return "#ffffff";
             const colorKey = layer === 'AGI' ? 'agi' : layer.toLowerCase() + '_abstraction';
             if (embeddedData.colors[colorKey] && embeddedData.colors[colorKey].primary) {
                 return embeddedData.colors[colorKey].primary;
             } else {
                 console.warn(`Color definition not found for layer: ${layer}. Using default.`);
                 return "#ffffff";
             }
         }

         // Adjust reference link on scroll/resize
         function adjustRefLinkPosition() {
             const legendElement = document.getElementById('legend');
             if (legendElement) {
                 const legendRect = legendElement.getBoundingClientRect();
                 // Position below the legend since it's back at the top
                 d3.select('#reference-link').style('top', `${legendRect.bottom + 10 + window.scrollY}px`);
                 d3.select('#reference-link').style('right', '20px'); // Match legend's right position
             }
         }
         window.addEventListener('scroll', adjustRefLinkPosition);
         window.addEventListener('resize', adjustRefLinkPosition);

    </script>
</body>
</html>